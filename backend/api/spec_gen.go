// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RYXU8bRxf+K9a870Urbb1W2krR3iUKqlCpoI1yhRCaeMd40X4xO0uELEvsugQauQoF",
	"NYimUhIVkaYoJjRcoKSQHzOsY/5FNbMf9trrxS62UeDK692ZM2ee55znnJkSyBuaaehIJxaQSsDKF5EG",
	"+ePYItIJe4CqOlkA0nQJ/B+jApDA/8TmJDGYIfLht6GFQFkoARMbJsJEQdxUHiNIkDwLub2CgTX2BGRI",
	"0BdE0RAQAFkyEZCARbCiz4GyABCzN6vIsRm2rchJgxVrVkYqIogPDz7fNwwVQZ19t025TwfKAsBowVYw",
	"Mznd9Ca2Vsyw0LrNmcigcX8e5Qkoz5QF0MRIaocIypqi8yeFII0/yMjKY8UkiqEDCRAMv8+M30naffAC",
	"YgyX2H9ICNJlhAZkju2wA7akibEVSoksaWg29C6ZKcWaNUykJ38kClFRguk2svxhcX+E0OtwgQ53hJCD",
	"VgA7eQxYnNTvmSEw15LJUbHUDyl3bU2DeGm4nAwMxH4VbiS50yJ0F0yjJJYmDEJQEkGXXiFU37NezXVD",
	"87+UGgE8UHQd4YHEZxudLdsSkrjtqZg1HezklC2o6AWDY+GDAm5NjQMBLCJs+c7nsrlsjrnKIgaaCpDA",
	"l9lc9isgABOSIt+uyJ3jj3OIQ8fCA7Ltj8tAAt8gMuaPYJMw1BDhiE23I0WdTerUaOUXWnlFKy9o5R/q",
	"fqBONUOwjTLUqXnPD731NbrseD89OtveqR+tUecDm+Lu0Mo2rbyllTXqut76HnUd6ux6j594J1vU2aLO",
	"CXW2GWhsnQWbBbIAdKixPSuFOxGOTQLYmkLQVCXFXXmGjbZMQ7f8PLiRy/F0MHQSdl+mqSp5DoQ4b/lS",
	"0jQYhcu5rVmojZ0R0y5VYPJbNupr35X4p3GdIKxDNXMX4UWEM2MYG5hHnRVqL4gB6dROj5Ybuy+pu9EJ",
	"JIFzjMKg1WQdkmlYCeRPGZbPfgAusshtQ17qC6kee9d4AjH+yhekKC50fYhWOTHZBkpV/ckbzseP8eDf",
	"OD3+vb62nkZVWQhTVizx3/E7Zd8HlgWdFPrZEZLYlsE8oZgUNPMpsJmaTefh1yW5BotgddWr/caRetYG",
	"oq8v6fGeqnWXDdTgcmsYodsNeKfWePX24+GbXhUHknwxQXLY60tgYUjiFh1Xehe4UbFVr6x4zw+ou1F/",
	"ehjqUR+iI/qdJ9Tz6Hz9udUcey1EyKl5q++8o9cft9+fVf+m7gZ1X9PKH+yr+55W9pLAbsEovSJfOzD3",
	"2sBsvKiy0pkKYGLI+l150BF0KwET0aBRoSsMrJeuPzo+c46uVhcdnl2H30CniaUPbE9ddehwehaHoz6B",
	"KhfvpPu6Zko+uA6z0e/rQmEUrX6KrO2f8Pe70XEgzN+Ug0AzutIlTiwFSPR0QBh1NAqJliOPP6liFZHW",
	"/eDRKgnpdedKUzCQvjqqB0NN1UjwezjUnC/4PxiqepX4vUjHsl49PVpuVULv4Qp1XlKndrb6c2Nn1Tve",
	"9NOp8eeB93g/AjzzWQGqVqsx1uYwYz5XoZn9mBlnPzTzK3Wr3NJT6m5+3r0Rsv3AHHUvFK9i/sVvH/fR",
	"I65kTc2rPePt+BajlkPeWF5hh8qDd+Hg1AJmWwhboobSOvLvEBgouD7XpUuAsLH6l7f2kDq1gMdUWbln",
	"IcxQYha4yaRr9wkjHy0JBGBjFUigSIgpiaLKvhUNi0g3czdzIjQV0Jm5U9iQ7Tz7k2TFkkSRYLhgzytZ",
	"gqGZtYrGg14tZW70Zou7B1gGBVsPKfIhYCsF/4NLreaLljNfy9uoRMyU/w0AAP//Fw2rXmkhAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
